@persist Cache:array

#include "xbyte_3d_engine/3dmath"

function void wirelink:cl() {
    This:egpClear()
}

function void wirelink:poly( I, [P1 P2 P3]:vector4, C:vector4 ) {
    This:egpPoly( I, P1, P2, P3 )
    This:egpColor( I, C )
}

function void wirelink:poly( I, [P1 P2 P3]:vector4, C:vector4, M:string ) {
    This:egpPoly( I, P1, P2, P3 )
    This:egpColor( I, C )
    This:egpMaterial( I, M )
}

function void table:graphics_update() {
    local Camera = This:camera()
    local S = This:screen()
    
    local Pos = Camera:pos()
    Pos = vec( Pos:x(), Pos:z(), Pos:y() )
    local Ang = Camera:angles():normalized()
    
    local Yaw = Ang:yaw()
    local Pitch = Ang:pitch()
    local Front = vec( cos( Yaw ) * cos( Pitch ), sin( Pitch ), sin( Yaw ) * cos( Pitch ) ):normalized() # - Center vector
    
    This:lookat( Pos, Pos + Front, vec( 0, 1, 0 ) ) # - Eye, Center, Up vectors
    
    local View = This:view() # - View matrix4
    local Viewport = This:viewport() # - Viewport matrix4
    local Project = This:projection() # - Projection matrix4
    
    local CameraEye = Ang:get_eye()
    
    foreach( O, Obj:table = This:objects() ) {
        Obj["RotatedLocal", array] = array()
        Obj["Translated", array] = array()
        
        local Ang = Obj:obj_ang():normalized()
        local Pos = Obj:obj_pos()
        Pos = vec( Pos:x(), Pos:z(), Pos:y() )
        local Model = identity4()
        
        Model = Model:translate( Pos ) # - Moving object
        
        Model = Model:rotate( Ang:roll(), 0, 0, 1 )
        Model = Model:rotate( Ang:pitch(), 1, 0, 0 )
        Model = Model:rotate( Ang:yaw(), 0, 1, 0 )
        
        Model = Model:scale( Obj:obj_scale() ) # - Scaling object
        
        local LocalPos = ( Pos - Obj:obj_pos() ):normalized() # - For shading
        
        foreach( I, V:vector = Obj:obj_vertices() ) { 
            local Clip = Project * View * Model * vec4( V, 1 )
            local NDC = vec( Clip ) / Clip:w()
            local Position = Viewport * vec4( NDC, 1 )
            
            Obj["RotatedLocal", array]:pushVector( NDC )
            Obj["Translated", array]:pushVector( vec( Position:x(), Position:y(), Clip:w() ) )
            
        }
        
        foreach( I:number, V:vector = Obj:obj_tri() ) {
            
            local Vtx1 = Obj:obj_rl()[V:x(), vector]
            local Vtx2 = Obj:obj_rl()[V:y(), vector]
            local Vtx3 = Obj:obj_rl()[V:z(), vector]
            
            local Vx = Obj:obj_tr()[V:x(), vector]
            local Vy = Obj:obj_tr()[V:y(), vector]
            local Vz = Obj:obj_tr()[V:z(), vector]
            
            local Normal = ( Vtx2 - Vtx1 ):cross( Vtx3 - Vtx1 ):normalized()
            local Shading = Normal:dot( ( LocalPos - ( Vtx1 + Vtx3 ) / 2 ):normalized() )
                
            local Index = Obj:obj_index() + I
            
            if( Vx:z() > 0 ) { Shading = 0 }
            if( Vy:z() > 0 ) { Shading = 0 }
            if( Vz:z() > 0 ) { Shading = 0 }
            
            if( Shading > 0 ) {
                Cache[Index, normal] = 1

                S:poly(Index, vec4( Vx:x(), Vx:y(), 0, 0),
                            vec4( Vy:x(), Vy:y(), 0, 1),
                            vec4( Vz:x(), Vz:y(), 1, 1),
                            vec4( sqrt( Shading ) * 255 ) )
            }
            elseif( Cache[Index, normal] ) {
                S:egpPoly( Index, vec2(), vec2(), vec2())
                
                Cache[Index, normal] = 0
            }
        }
    }
}
